# Entity Structure

An entity file in SeaORM corresponds to a table in the database and should define the specifications including columns, keys and relations.

It can be written by hand, or generated by `sea-orm-cli`.

Lets go through the sections of the example [cake](https://github.com/SeaQL/sea-orm/blob/master/src/tests_cfg/cake.rs) entity.

## Entity

By implementing the [`EntityTrait`](https://docs.rs/sea-orm/*/sea_orm/entity/trait.EntityTrait.html), you can perform CRUD operations on the given table.

```rust
#[derive(Copy, Clone, Default, Debug, DeriveEntity)]
pub struct Entity;

impl EntityName for Entity {
    fn table_name(&self) -> &str {
        "cake"
    }
}
```

## Column

An enum representing all columns in this table.

```rust
#[derive(Copy, Clone, Debug, EnumIter, DeriveColumn)]
pub enum Column {
    Id,
    Name,
}

impl ColumnTrait for Column {
    type EntityName = Entity;

    fn def(&self) -> ColumnDef {
        match self {
            Self::Id => ColumnType::Integer.def(),
            Self::Name => ColumnType::String(None).def(),
        }
    }
}
```

All column names are assumed to be in snake-case.

```rust
pub enum Column {
    Id,      // maps to "id" in SQL
    Name,    // maps to "name" in SQL
    CreateAt // maps to "create_at" in SQL
}
```

To specify the datatype of each column, the [`ColumnType`](https://docs.rs/sea-orm/*/sea_orm/entity/enum.ColumnType.html) enum can be used.

### Additional properties

- Unique
- Indexed
- Nullable

```rust
ColumnType::String(None).def().unique().indexed().null()
```

## Primary Key

An enum representing the primary key of this table. If it is a composite key, then multiple enum variants can be added.

The `ValueType` define the return type of last insert id in [`InsertResult`](https://docs.rs/sea-orm/*/sea_orm/struct.InsertResult.html). if it is a composite key, then a tuple can be defined to represent it.

The `auto_increment` define if the primary key has to be set or not during insert.

```rust
#[derive(Copy, Clone, Debug, EnumIter, DerivePrimaryKey)]
pub enum PrimaryKey {
    Id,
}

impl PrimaryKeyTrait for PrimaryKey {
    type ValueType = i32;

    fn auto_increment() -> bool {
        true
    }
}
```

Composite key

```rust
pub enum PrimaryKey {
    CakeId,
    FruitId,
}

impl PrimaryKeyTrait for PrimaryKey {
    type ValueType = (i32, i32);

    fn auto_increment() -> bool {
        false
    }
}
```

## Model

The Rust struct for storing the query results.

```rust
#[derive(Clone, Debug, PartialEq, DeriveModel, DeriveActiveModel)]
pub struct Model {
    pub id: i32,
    pub name: String,
}
```

### Nullable Attribute

If the table column is nullable, wrap it with an `Option`.

```rust {3}
pub struct Model {
    pub id: i32,
    pub name: Option<String>,
}
```

## Active Model

The `ActiveModel` has all the attributes of its corresponding `Model` but all attributes are wrapped in an [`ActiveValue`](https://docs.rs/sea-orm/*/sea_orm/entity/struct.ActiveValue.html).

```rust
#[derive(Clone, Debug, PartialEq)]
pub struct ActiveModel {
    pub id: ActiveValue<i32>,
    pub name: ActiveValue<Option<String>>,
}
```

### Active Model Behavior

Handler for different actions on an `ActiveModel`.

```rust
impl ActiveModelBehavior for ActiveModel {
    /// Create a new ActiveModel with default values. Also used by `Default::default()`.
    fn new() -> Self {
        <Self as ActiveModelTrait>::default()
    }

    /// Will be called before saving
    fn before_save(self) -> Self {
        self
    }

    /// Will be called after saving
    fn after_save(self) -> Self {
        self
    }

    /// Will be called before deleting
    fn before_delete(self) -> Self {
        self
    }
}
```

If no customization is needed, simply write:

```rust
impl ActiveModelBehavior for ActiveModel {}
```

## Relation

Specifying the relations with other entities.

```rust
#[derive(Copy, Clone, Debug, EnumIter)]
pub enum Relation {
    Fruit,
}

impl RelationTrait for Relation {
    fn def(&self) -> RelationDef {
        match self {
            Self::Fruit => Entity::has_many(super::fruit::Entity).into(),
        }
    }
}
```

## Related

Defining join paths to help you query related entities together, especially helpful in many-to-many relations.

```rust
impl Related<super::fruit::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Fruit.def()
    }
}

impl Related<super::filling::Entity> for Entity {
    fn to() -> RelationDef {
        super::cake_filling::Relation::Filling.def()
    }

    fn via() -> Option<RelationDef> {
        Some(super::cake_filling::Relation::Cake.def().rev())
    }
}
```
