# Generated project structure

On this article we will describe the generated project structure.

All examples are based on https://dev.mysql.com/doc/sakila/en/ database.

## ORM folder

Here we can find SeaORM generated entities. Its the layer between our application and the database.

You can read more about it here https://www.sea-ql.org/SeaORM/docs/index

### Entities

This folder contains all SeaORM entities.

#### Example entity

```rust
use sea_orm::entity::prelude::*;

#[derive(Copy, Clone, Default, Debug, DeriveEntity)]
pub struct Entity;

impl EntityName for Entity {
    fn table_name(&self) -> &str {
        "actor"
    }
}

#[derive(Clone, Debug, PartialEq, DeriveModel, DeriveActiveModel)]
pub struct Model {
    pub actor_id: u16,
    pub first_name: String,
    pub last_name: String,
    pub last_update: DateTimeUtc,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveColumn)]
pub enum Column {
    ActorId,
    FirstName,
    LastName,
    LastUpdate,
}

#[derive(Copy, Clone, Debug, EnumIter, DerivePrimaryKey)]
pub enum PrimaryKey {
    ActorId,
}

impl PrimaryKeyTrait for PrimaryKey {
    type ValueType = u16;
    fn auto_increment() -> bool {
        true
    }
}

#[derive(Copy, Clone, Debug, EnumIter)]
pub enum Relation {
    FilmActor,
}

impl ColumnTrait for Column {
    type EntityName = Entity;
    fn def(&self) -> ColumnDef {
        match self {
            Self::ActorId => ColumnType::SmallUnsigned.def(),
            Self::FirstName => ColumnType::String(Some(45u32)).def(),
            Self::LastName => ColumnType::String(Some(45u32)).def(),
            Self::LastUpdate => ColumnType::Timestamp.def(),
        }
    }
}

impl RelationTrait for Relation {
    fn def(&self) -> RelationDef {
        match self {
            Self::FilmActor => Entity::has_many(super::film_actor::Entity).into(),
        }
    }
}

impl Related<super::film_actor::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::FilmActor.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
```

### `sea_orm_active_enums.rs`

This file contains all database enumerations.

#### Example content
```rust
//! SeaORM Entity. Generated by sea-orm-codegen 0.8.0

use sea_orm::entity::prelude::*;

#[derive(Debug, Clone, PartialEq, EnumIter, DeriveActiveEnum)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "rating")]
pub enum Rating {
    #[sea_orm(string_value = "G")]
    G,
    #[sea_orm(string_value = "PG")]
    Pg,
    #[sea_orm(string_value = "PG-13")]
    Pg13,
    #[sea_orm(string_value = "R")]
    R,
    #[sea_orm(string_value = "NC-17")]
    Nc17,
}
```

## GraphQL folder

Here you can find the GraphQL entities, queries and utility types.

### Type filter

This is a utility type used to represent different filter types for queries.

### ORM dataloader

This is a utility type used to represent the database connection. Its initialized on server startup and its stored in GraphQL context.

For more info about GraphQL context https://async-graphql.github.io/async-graphql/en/context.html

### Root node

This file contains root GraphQL node with queries (WIP: mutations). It allows to query entities utilizing filters and pagination.

#### PaginatedResult example
```rust
#[graphql(concrete(name = "PaginatedCountryResult", params(entities::country::Model)))]
pub struct PaginatedResult<T: async_graphql::ObjectType> {
    pub data: Vec<T>,
    pub pages: usize,
    pub current: usize,
}
```

#### QueryRoot example
```rust
pub struct QueryRoot;
#[async_graphql::Object]
impl QueryRoot {
    async fn payment<'a>(
        &self,
        ctx: &async_graphql::Context<'a>,
        filters: Option<entities::payment::Filter>,
        pagination: Option<PaginationInput>,
    ) -> PaginatedResult<entities::payment::Model> {
        let db: &DatabaseConnection = ctx.data::<DatabaseConnection>().unwrap();

        let stmt = entities::payment::Entity::find().filter(entities::payment::filter_recursive(filters));

        if let Some(pagination) = pagination {
            let paginator = stmt.paginate(db, pagination.limit);
            let data: Vec<entities::payment::Model> =
                paginator.fetch_page(pagination.page).await.unwrap();
            let pages = paginator.num_pages().await.unwrap();
            PaginatedResult {
                data,
                pages,
                current: pagination.page,
            }
        } else {
            let data: Vec<entities::payment::Model> = stmt.all(db).await.unwrap();
            PaginatedResult {
                data,
                pages: 1,
                current: 1,
            }
        }
    }
    [...]
}
```

### Entities

The entity implements most of the features (related queries, utility functions, data loaders, etc.). This file is required to make the SeaORM entity compatible with GraphQL.

#### Example entity

```rust
use crate::graphql::*;
pub use crate::orm::actor::*;
use sea_orm::prelude::*;
#[async_graphql::Object(name = "Actor")]
impl Model {
    pub async fn actor_id(&self) -> &u16 {
        &self.actor_id
    }
    pub async fn first_name(&self) -> &String {
        &self.first_name
    }
    pub async fn last_name(&self) -> &String {
        &self.last_name
    }
    pub async fn last_update(&self) -> &DateTimeUtc {
        &self.last_update
    }
    pub async fn actor_film_actor<'a>(
        &self,
        ctx: &async_graphql::Context<'a>,
    ) -> Vec<crate::orm::film_actor::Model> {
        let data_loader = ctx
            .data::<async_graphql::dataloader::DataLoader<OrmDataloader>>()
            .unwrap();
        let key = ActorFilmActorFK(self.actor_id.clone());
        let data: Option<_> = data_loader.load_one(key).await.unwrap();
        data.unwrap_or(vec![])
    }
}
#[derive(async_graphql :: InputObject, Debug)]
#[graphql(name = "ActorFilter")]
pub struct Filter {
    pub or: Option<Vec<Box<Filter>>>,
    pub and: Option<Vec<Box<Filter>>>,
    pub actor_id: Option<TypeFilter<u16>>,
    pub first_name: Option<TypeFilter<String>>,
    pub last_name: Option<TypeFilter<String>>,
    pub last_update: Option<TypeFilter<DateTimeUtc>>,
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct ActorFilmActorFK(u16);
#[async_trait::async_trait]
impl async_graphql::dataloader::Loader<ActorFilmActorFK> for OrmDataloader {
    type Value = Vec<crate::orm::film_actor::Model>;
    type Error = std::sync::Arc<sea_orm::error::DbErr>;
    async fn load(
        &self,
        keys: &[ActorFilmActorFK],
    ) -> Result<std::collections::HashMap<ActorFilmActorFK, Self::Value>, Self::Error> {
        let filter = sea_orm::Condition::all().add(sea_orm::sea_query::SimpleExpr::Binary(
            Box::new(sea_orm::sea_query::SimpleExpr::Tuple(vec![
                sea_orm::sea_query::Expr::col(
                    crate::orm::film_actor::Column::ActorId.as_column_ref(),
                )
                .into_simple_expr(),
            ])),
            sea_orm::sea_query::BinOper::In,
            Box::new(sea_orm::sea_query::SimpleExpr::Tuple(
                keys.iter()
                    .map(|tuple| {
                        sea_orm::sea_query::SimpleExpr::Values(vec![tuple.0.clone().into()])
                    })
                    .collect(),
            )),
        ));
        use itertools::Itertools;
        Ok(crate::orm::film_actor::Entity::find()
            .filter(filter)
            .all(&self.db)
            .await?
            .into_iter()
            .map(|model| {
                let key = ActorFilmActorFK(model.actor_id.clone());
                (key, model)
            })
            .into_group_map())
    }
}

pub fn filter_recursive(
    root_filter: Option<entities::film_actor::Filter>,
) -> sea_orm::Condition {
    let mut condition = sea_orm::Condition::all();
    if let Some(current_filter) = root_filter {
        if let Some(or_filters) = current_filter.or {
            let or_condition = or_filters.into_iter().fold(
                sea_orm::Condition::any(),
                |fold_condition, filter| {
                    fold_condition.add(filter_recursive(Some(*filter)))
                },
            );
            condition = condition.add(or_condition);
        }
        if let Some(and_filters) = current_filter.and {
            let and_condition = and_filters.into_iter().fold(
                sea_orm::Condition::all(),
                |fold_condition, filter| {
                    fold_condition.add(filter_recursive(Some(*filter)))
                },
            );
            condition = condition.add(and_condition);
        }
        if let Some(actor_id) = current_filter.actor_id {
            if let Some(eq_value) = actor_id.eq {
                condition =
                    condition.add(entities::film_actor::Column::ActorId.eq(eq_value))
            }
            if let Some(ne_value) = actor_id.ne {
                condition =
                    condition.add(entities::film_actor::Column::ActorId.ne(ne_value))
            }
        }
        if let Some(film_id) = current_filter.film_id {
            if let Some(eq_value) = film_id.eq {
                condition = condition.add(entities::film_actor::Column::FilmId.eq(eq_value))
            }
            if let Some(ne_value) = film_id.ne {
                condition = condition.add(entities::film_actor::Column::FilmId.ne(ne_value))
            }
        }
        if let Some(last_update) = current_filter.last_update {
            if let Some(eq_value) = last_update.eq {
                condition =
                    condition.add(entities::film_actor::Column::LastUpdate.eq(eq_value))
            }
            if let Some(ne_value) = last_update.ne {
                condition =
                    condition.add(entities::film_actor::Column::LastUpdate.ne(ne_value))
            }
        }
    }
    condition
}
```

### Enums

The enums acts as a compatibility layer for SeaORM enums to work with GraphQL.


#### Example enum

```rust
use crate::orm::sea_orm_active_enums;
use async_graphql::*;
use sea_orm::entity::prelude::*;
#[derive(Debug, Copy, Clone, Eq, PartialEq, EnumIter, DeriveActiveEnum, Enum)]
#[graphql(remote = "sea_orm_active_enums::Rating")]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "Rating")]
pub enum Rating {
    #[sea_orm(string_value = "G")]
    G,
    #[sea_orm(string_value = "PG")]
    Pg,
    #[sea_orm(string_value = "PG-13")]
    Pg13,
    #[sea_orm(string_value = "R")]
    R,
    #[sea_orm(string_value = "NC-17")]
    Nc17,
}
```

## Main program


The main program of the application. It initializes database connections, enables tracing, populate application context and serve GraphQL HTTP API.


```rust
use async_graphql::{
    dataloader::DataLoader,
    http::{playground_source, GraphQLPlaygroundConfig},
    EmptyMutation, EmptySubscription, Schema,
};
use async_graphql_poem::GraphQL;
use generated::*;
use poem::{get, handler, listener::TcpListener, web::Html, IntoResponse, Route, Server};
use sea_orm::Database;
#[handler]
async fn graphql_playground() -> impl IntoResponse {
    Html(playground_source(GraphQLPlaygroundConfig::new("/")))
}
#[tokio::main]
async fn main() {
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::DEBUG)
        .with_test_writer()
        .init();
    let database = Database::connect("mysql://root:root@127.0.0.1/sakila")
        .await
        .unwrap();
    let orm_dataloader: DataLoader<OrmDataloader> = DataLoader::new(
        OrmDataloader {
            db: database.clone(),
        },
        tokio::spawn,
    );
    let schema = Schema::build(QueryRoot, EmptyMutation, EmptySubscription)
        .data(database)
        .data(orm_dataloader)
        .finish();
    let app = Route::new().at("/", get(graphql_playground).post(GraphQL::new(schema)));
    println!("Playground: http://localhost:8000");
    Server::new(TcpListener::bind("0.0.0.0:8000"))
        .run(app)
        .await
        .unwrap();
}
```

## Generated GraphQL Schema

We can inspect a part of the generated GraphQL schema bellow.

```typescript
schema {
  query: QueryRoot
}

input PaginationInput {
  limit: Int!
  page: Int!
}

type Actor {
  actorId: Int!
  firstName: String!
  lastName: String!
  lastUpdate: DateTime!
  actorFilmActor: [FilmActor!]!
}

input ActorFilter {
  or: [ActorFilter!]
  and: [ActorFilter!]
  actorId: SmallUnsignedFilter
  firstName: StringFilter
  lastName: StringFilter
  lastUpdate: DateTimeUtcFilter
}

type FilmActor {
  actorId: Int!
  filmId: Int!
  lastUpdate: DateTime!
  actorActor: Actor!
  filmFilm: Film!
}

type Film {
    [...]
}

type QueryRoot {
  film(filters: FilmFilter, pagination: PaginationInput): PaginatedFilmResult!
  actor(
    filters: ActorFilter
    pagination: PaginationInput
  ):    !
  filmActor(
    filters: FilmActorFilter
    pagination: PaginationInput
  ): PaginatedFilmActorResult!
  [...]
}

type PaginatedActorResult {
  data: [Actor!]!
  pages: Int!
  current: Int!
}

type PaginatedFilmResult {
    [...]
}

[...]
```